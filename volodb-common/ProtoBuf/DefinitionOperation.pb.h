// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DefinitionOperation.proto

#ifndef PROTOBUF_DefinitionOperation_2eproto__INCLUDED
#define PROTOBUF_DefinitionOperation_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Column.pb.h"
#include "Operation.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DefinitionOperation_2eproto();
void protobuf_AssignDesc_DefinitionOperation_2eproto();
void protobuf_ShutdownFile_DefinitionOperation_2eproto();

class DefinitionOpertion;
class CreateDatabaseOperation;
class DropDatabaseOperation;
class CreateStoreOperation;
class DropStoreOperation;

// ===================================================================

class DefinitionOpertion : public ::google::protobuf::Message {
 public:
  DefinitionOpertion();
  virtual ~DefinitionOpertion();

  DefinitionOpertion(const DefinitionOpertion& from);

  inline DefinitionOpertion& operator=(const DefinitionOpertion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DefinitionOpertion& default_instance();

  void Swap(DefinitionOpertion* other);

  // implements Message ----------------------------------------------

  DefinitionOpertion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DefinitionOpertion& from);
  void MergeFrom(const DefinitionOpertion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .StoreInfo store_info = 1;
  inline bool has_store_info() const;
  inline void clear_store_info();
  static const int kStoreInfoFieldNumber = 1;
  inline const ::StoreInfo& store_info() const;
  inline ::StoreInfo* mutable_store_info();
  inline ::StoreInfo* release_store_info();
  inline void set_allocated_store_info(::StoreInfo* store_info);

  // @@protoc_insertion_point(class_scope:DefinitionOpertion)
 private:
  inline void set_has_store_info();
  inline void clear_has_store_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::StoreInfo* store_info_;
  friend void  protobuf_AddDesc_DefinitionOperation_2eproto();
  friend void protobuf_AssignDesc_DefinitionOperation_2eproto();
  friend void protobuf_ShutdownFile_DefinitionOperation_2eproto();

  void InitAsDefaultInstance();
  static DefinitionOpertion* default_instance_;
};
// -------------------------------------------------------------------

class CreateDatabaseOperation : public ::google::protobuf::Message {
 public:
  CreateDatabaseOperation();
  virtual ~CreateDatabaseOperation();

  CreateDatabaseOperation(const CreateDatabaseOperation& from);

  inline CreateDatabaseOperation& operator=(const CreateDatabaseOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDatabaseOperation& default_instance();

  void Swap(CreateDatabaseOperation* other);

  // implements Message ----------------------------------------------

  CreateDatabaseOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateDatabaseOperation& from);
  void MergeFrom(const CreateDatabaseOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string database_name = 1;
  inline bool has_database_name() const;
  inline void clear_database_name();
  static const int kDatabaseNameFieldNumber = 1;
  inline const ::std::string& database_name() const;
  inline void set_database_name(const ::std::string& value);
  inline void set_database_name(const char* value);
  inline void set_database_name(const char* value, size_t size);
  inline ::std::string* mutable_database_name();
  inline ::std::string* release_database_name();
  inline void set_allocated_database_name(::std::string* database_name);

  // @@protoc_insertion_point(class_scope:CreateDatabaseOperation)
 private:
  inline void set_has_database_name();
  inline void clear_has_database_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* database_name_;
  friend void  protobuf_AddDesc_DefinitionOperation_2eproto();
  friend void protobuf_AssignDesc_DefinitionOperation_2eproto();
  friend void protobuf_ShutdownFile_DefinitionOperation_2eproto();

  void InitAsDefaultInstance();
  static CreateDatabaseOperation* default_instance_;
};
// -------------------------------------------------------------------

class DropDatabaseOperation : public ::google::protobuf::Message {
 public:
  DropDatabaseOperation();
  virtual ~DropDatabaseOperation();

  DropDatabaseOperation(const DropDatabaseOperation& from);

  inline DropDatabaseOperation& operator=(const DropDatabaseOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropDatabaseOperation& default_instance();

  void Swap(DropDatabaseOperation* other);

  // implements Message ----------------------------------------------

  DropDatabaseOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropDatabaseOperation& from);
  void MergeFrom(const DropDatabaseOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string database_name = 1;
  inline bool has_database_name() const;
  inline void clear_database_name();
  static const int kDatabaseNameFieldNumber = 1;
  inline const ::std::string& database_name() const;
  inline void set_database_name(const ::std::string& value);
  inline void set_database_name(const char* value);
  inline void set_database_name(const char* value, size_t size);
  inline ::std::string* mutable_database_name();
  inline ::std::string* release_database_name();
  inline void set_allocated_database_name(::std::string* database_name);

  // @@protoc_insertion_point(class_scope:DropDatabaseOperation)
 private:
  inline void set_has_database_name();
  inline void clear_has_database_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* database_name_;
  friend void  protobuf_AddDesc_DefinitionOperation_2eproto();
  friend void protobuf_AssignDesc_DefinitionOperation_2eproto();
  friend void protobuf_ShutdownFile_DefinitionOperation_2eproto();

  void InitAsDefaultInstance();
  static DropDatabaseOperation* default_instance_;
};
// -------------------------------------------------------------------

class CreateStoreOperation : public ::google::protobuf::Message {
 public:
  CreateStoreOperation();
  virtual ~CreateStoreOperation();

  CreateStoreOperation(const CreateStoreOperation& from);

  inline CreateStoreOperation& operator=(const CreateStoreOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateStoreOperation& default_instance();

  void Swap(CreateStoreOperation* other);

  // implements Message ----------------------------------------------

  CreateStoreOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateStoreOperation& from);
  void MergeFrom(const CreateStoreOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .StoreInfo store_info = 1;
  inline bool has_store_info() const;
  inline void clear_store_info();
  static const int kStoreInfoFieldNumber = 1;
  inline const ::StoreInfo& store_info() const;
  inline ::StoreInfo* mutable_store_info();
  inline ::StoreInfo* release_store_info();
  inline void set_allocated_store_info(::StoreInfo* store_info);

  // repeated .ColumnInfo column = 2;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::ColumnInfo& column(int index) const;
  inline ::ColumnInfo* mutable_column(int index);
  inline ::ColumnInfo* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::ColumnInfo >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::ColumnInfo >*
      mutable_column();

  // @@protoc_insertion_point(class_scope:CreateStoreOperation)
 private:
  inline void set_has_store_info();
  inline void clear_has_store_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::StoreInfo* store_info_;
  ::google::protobuf::RepeatedPtrField< ::ColumnInfo > column_;
  friend void  protobuf_AddDesc_DefinitionOperation_2eproto();
  friend void protobuf_AssignDesc_DefinitionOperation_2eproto();
  friend void protobuf_ShutdownFile_DefinitionOperation_2eproto();

  void InitAsDefaultInstance();
  static CreateStoreOperation* default_instance_;
};
// -------------------------------------------------------------------

class DropStoreOperation : public ::google::protobuf::Message {
 public:
  DropStoreOperation();
  virtual ~DropStoreOperation();

  DropStoreOperation(const DropStoreOperation& from);

  inline DropStoreOperation& operator=(const DropStoreOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropStoreOperation& default_instance();

  void Swap(DropStoreOperation* other);

  // implements Message ----------------------------------------------

  DropStoreOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropStoreOperation& from);
  void MergeFrom(const DropStoreOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .StoreInfo store_info = 1;
  inline bool has_store_info() const;
  inline void clear_store_info();
  static const int kStoreInfoFieldNumber = 1;
  inline const ::StoreInfo& store_info() const;
  inline ::StoreInfo* mutable_store_info();
  inline ::StoreInfo* release_store_info();
  inline void set_allocated_store_info(::StoreInfo* store_info);

  // @@protoc_insertion_point(class_scope:DropStoreOperation)
 private:
  inline void set_has_store_info();
  inline void clear_has_store_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::StoreInfo* store_info_;
  friend void  protobuf_AddDesc_DefinitionOperation_2eproto();
  friend void protobuf_AssignDesc_DefinitionOperation_2eproto();
  friend void protobuf_ShutdownFile_DefinitionOperation_2eproto();

  void InitAsDefaultInstance();
  static DropStoreOperation* default_instance_;
};
// ===================================================================


// ===================================================================

// DefinitionOpertion

// required .StoreInfo store_info = 1;
inline bool DefinitionOpertion::has_store_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DefinitionOpertion::set_has_store_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DefinitionOpertion::clear_has_store_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DefinitionOpertion::clear_store_info() {
  if (store_info_ != NULL) store_info_->::StoreInfo::Clear();
  clear_has_store_info();
}
inline const ::StoreInfo& DefinitionOpertion::store_info() const {
  // @@protoc_insertion_point(field_get:DefinitionOpertion.store_info)
  return store_info_ != NULL ? *store_info_ : *default_instance_->store_info_;
}
inline ::StoreInfo* DefinitionOpertion::mutable_store_info() {
  set_has_store_info();
  if (store_info_ == NULL) store_info_ = new ::StoreInfo;
  // @@protoc_insertion_point(field_mutable:DefinitionOpertion.store_info)
  return store_info_;
}
inline ::StoreInfo* DefinitionOpertion::release_store_info() {
  clear_has_store_info();
  ::StoreInfo* temp = store_info_;
  store_info_ = NULL;
  return temp;
}
inline void DefinitionOpertion::set_allocated_store_info(::StoreInfo* store_info) {
  delete store_info_;
  store_info_ = store_info;
  if (store_info) {
    set_has_store_info();
  } else {
    clear_has_store_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DefinitionOpertion.store_info)
}

// -------------------------------------------------------------------

// CreateDatabaseOperation

// required string database_name = 1;
inline bool CreateDatabaseOperation::has_database_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateDatabaseOperation::set_has_database_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateDatabaseOperation::clear_has_database_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateDatabaseOperation::clear_database_name() {
  if (database_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_->clear();
  }
  clear_has_database_name();
}
inline const ::std::string& CreateDatabaseOperation::database_name() const {
  // @@protoc_insertion_point(field_get:CreateDatabaseOperation.database_name)
  return *database_name_;
}
inline void CreateDatabaseOperation::set_database_name(const ::std::string& value) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(value);
  // @@protoc_insertion_point(field_set:CreateDatabaseOperation.database_name)
}
inline void CreateDatabaseOperation::set_database_name(const char* value) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CreateDatabaseOperation.database_name)
}
inline void CreateDatabaseOperation::set_database_name(const char* value, size_t size) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CreateDatabaseOperation.database_name)
}
inline ::std::string* CreateDatabaseOperation::mutable_database_name() {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CreateDatabaseOperation.database_name)
  return database_name_;
}
inline ::std::string* CreateDatabaseOperation::release_database_name() {
  clear_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = database_name_;
    database_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateDatabaseOperation::set_allocated_database_name(::std::string* database_name) {
  if (database_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete database_name_;
  }
  if (database_name) {
    set_has_database_name();
    database_name_ = database_name;
  } else {
    clear_has_database_name();
    database_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDatabaseOperation.database_name)
}

// -------------------------------------------------------------------

// DropDatabaseOperation

// required string database_name = 1;
inline bool DropDatabaseOperation::has_database_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropDatabaseOperation::set_has_database_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropDatabaseOperation::clear_has_database_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropDatabaseOperation::clear_database_name() {
  if (database_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_->clear();
  }
  clear_has_database_name();
}
inline const ::std::string& DropDatabaseOperation::database_name() const {
  // @@protoc_insertion_point(field_get:DropDatabaseOperation.database_name)
  return *database_name_;
}
inline void DropDatabaseOperation::set_database_name(const ::std::string& value) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(value);
  // @@protoc_insertion_point(field_set:DropDatabaseOperation.database_name)
}
inline void DropDatabaseOperation::set_database_name(const char* value) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DropDatabaseOperation.database_name)
}
inline void DropDatabaseOperation::set_database_name(const char* value, size_t size) {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  database_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DropDatabaseOperation.database_name)
}
inline ::std::string* DropDatabaseOperation::mutable_database_name() {
  set_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    database_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DropDatabaseOperation.database_name)
  return database_name_;
}
inline ::std::string* DropDatabaseOperation::release_database_name() {
  clear_has_database_name();
  if (database_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = database_name_;
    database_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DropDatabaseOperation::set_allocated_database_name(::std::string* database_name) {
  if (database_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete database_name_;
  }
  if (database_name) {
    set_has_database_name();
    database_name_ = database_name;
  } else {
    clear_has_database_name();
    database_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DropDatabaseOperation.database_name)
}

// -------------------------------------------------------------------

// CreateStoreOperation

// required .StoreInfo store_info = 1;
inline bool CreateStoreOperation::has_store_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateStoreOperation::set_has_store_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateStoreOperation::clear_has_store_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateStoreOperation::clear_store_info() {
  if (store_info_ != NULL) store_info_->::StoreInfo::Clear();
  clear_has_store_info();
}
inline const ::StoreInfo& CreateStoreOperation::store_info() const {
  // @@protoc_insertion_point(field_get:CreateStoreOperation.store_info)
  return store_info_ != NULL ? *store_info_ : *default_instance_->store_info_;
}
inline ::StoreInfo* CreateStoreOperation::mutable_store_info() {
  set_has_store_info();
  if (store_info_ == NULL) store_info_ = new ::StoreInfo;
  // @@protoc_insertion_point(field_mutable:CreateStoreOperation.store_info)
  return store_info_;
}
inline ::StoreInfo* CreateStoreOperation::release_store_info() {
  clear_has_store_info();
  ::StoreInfo* temp = store_info_;
  store_info_ = NULL;
  return temp;
}
inline void CreateStoreOperation::set_allocated_store_info(::StoreInfo* store_info) {
  delete store_info_;
  store_info_ = store_info;
  if (store_info) {
    set_has_store_info();
  } else {
    clear_has_store_info();
  }
  // @@protoc_insertion_point(field_set_allocated:CreateStoreOperation.store_info)
}

// repeated .ColumnInfo column = 2;
inline int CreateStoreOperation::column_size() const {
  return column_.size();
}
inline void CreateStoreOperation::clear_column() {
  column_.Clear();
}
inline const ::ColumnInfo& CreateStoreOperation::column(int index) const {
  // @@protoc_insertion_point(field_get:CreateStoreOperation.column)
  return column_.Get(index);
}
inline ::ColumnInfo* CreateStoreOperation::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:CreateStoreOperation.column)
  return column_.Mutable(index);
}
inline ::ColumnInfo* CreateStoreOperation::add_column() {
  // @@protoc_insertion_point(field_add:CreateStoreOperation.column)
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ColumnInfo >&
CreateStoreOperation::column() const {
  // @@protoc_insertion_point(field_list:CreateStoreOperation.column)
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::ColumnInfo >*
CreateStoreOperation::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:CreateStoreOperation.column)
  return &column_;
}

// -------------------------------------------------------------------

// DropStoreOperation

// required .StoreInfo store_info = 1;
inline bool DropStoreOperation::has_store_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropStoreOperation::set_has_store_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropStoreOperation::clear_has_store_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropStoreOperation::clear_store_info() {
  if (store_info_ != NULL) store_info_->::StoreInfo::Clear();
  clear_has_store_info();
}
inline const ::StoreInfo& DropStoreOperation::store_info() const {
  // @@protoc_insertion_point(field_get:DropStoreOperation.store_info)
  return store_info_ != NULL ? *store_info_ : *default_instance_->store_info_;
}
inline ::StoreInfo* DropStoreOperation::mutable_store_info() {
  set_has_store_info();
  if (store_info_ == NULL) store_info_ = new ::StoreInfo;
  // @@protoc_insertion_point(field_mutable:DropStoreOperation.store_info)
  return store_info_;
}
inline ::StoreInfo* DropStoreOperation::release_store_info() {
  clear_has_store_info();
  ::StoreInfo* temp = store_info_;
  store_info_ = NULL;
  return temp;
}
inline void DropStoreOperation::set_allocated_store_info(::StoreInfo* store_info) {
  delete store_info_;
  store_info_ = store_info;
  if (store_info) {
    set_has_store_info();
  } else {
    clear_has_store_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DropStoreOperation.store_info)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DefinitionOperation_2eproto__INCLUDED
